from argparse import ArgumentParser
from cv2 import resize, INTER_LINEAR
from diffusers import StableDiffusionUpscalePipeline
from os import makedirs
from os.path import abspath
from pathlib import Path
from PIL import Image

import numpy as np
import torch as tr
import pyexr as px

from pbrt import adapter, material, writer

from vobj.dimension import get_pdim, HDR
from vobj.operation import build_mask, erode_mask
from vobj.validator import is_ccw
from vobj.transform import (rotate_env_map, ldr_to_hdr, image_to_world, 
                            convolve_ref_depth)

from terminal import get_logger, verify_path, log_output
from warnings import filterwarnings

if __name__ == "__main__":
    parser = ArgumentParser(
        description="Generates resources for rendering with pbrt.")

    parser.add_argument('-debug', action='store_true',
        help="run in debug mode")
    parser.add_argument('-cache', action='store_true',
        help="skip the generation of env maps if they are already existed")
    parser.add_argument('-upscale', action='store_true',
        help="upscale Pratul et al.'s env map with StableDiffuser")
    parser.add_argument('--res-dir', type=str, required=True, 
        help="path to the directory containing files generated by mapgen.py")
    parser.add_argument('--fov', type=float, default=63.5, 
        help="field of view in the x-axis, default to 63.5")
    parser.add_argument('--ksize', type=int, default=21,
        help="the size of the kernel convolved with the depth map")
    parser.add_argument('--w-irois', type=float, default=1.0,
        help="weight factor for Li et al.'s env map, default to 1.0")
    parser.add_argument('--w-house', type=float, default=1.0,
        help="weight factor for Pratul et al.'s env map, default to 1.0")
    parser.add_argument('--g-fraction', type=float, default=0.25,
        help="fraction of Li et al.'s env map to fill with 0, default to 0.5")
    parser.add_argument('--obj-material', type=str, default='glossy', 
        help="material of the virtual object, one of ['glossy', 'diffuse']")
    parser.add_argument('--obj-scale', type=float, default=0.1, 
        help="uniform scaling factor applied to the virtual object")
    parser.add_argument('--obj-rotate', default=[0.0, 0.0, 1.0, 0.0],
        type=float, nargs=4, help="orientation applied to the virtual object")
    parser.add_argument('--pixel-samples', type=int, default=1024, 
        help="pixel sampling rate for I_all and I_pln scenes, default to 1024")

    args = parser.parse_args()

    verbose = 'DEBUG' if args.debug else 'INFO'
    logger = get_logger(__name__, verbose)

    # All resource files
    res_dir = Path(abspath(args.res_dir))
    target_file = res_dir/"target.png"
    coords_file = res_dir/"coords.npz"
    normal_file = res_dir/"normal.png"
    albedo_file = res_dir/"albedo.png"
    rdepth_file = res_dir/"ref_depth.npy"
    rough_file = res_dir/"rough.png"
    irois_file = res_dir/"irois.npy"
    house_file = res_dir/"lighthouse.png"

    # Verify the existence of all resources
    try:
        verify_path(logger, res_dir)
        verify_path(logger, target_file)
        verify_path(logger, coords_file)
        verify_path(logger, normal_file)
        verify_path(logger, albedo_file)
        verify_path(logger, rdepth_file)
        verify_path(logger, rough_file)
        verify_path(logger, irois_file)
        verify_path(logger, house_file)
    except FileNotFoundError:
        exit(1)

    if not args.obj_material in ['glossy', 'diffuse']:
        logger.error(f"unsupported material {args.obj_material}")
        exit(1)

    if args.g_fraction < 0.0 or args.g_fraction > 1.0:
        logger.error(f"invalid ground fraction provided: {args.g_fraction}")
        exit(1)

    if args.w_irois <= 0.0 and args.w_house <= 0.0:
        logger.error(f"received weights {args.w_irois} and {args.w_house}")
        logger.error(f"cannot discard both env maps from the rendering!")
        exit(1)

    # Generate pbrt resources to a separate folder
    out_dir = res_dir/"pbrt"
    makedirs(out_dir, exist_ok=True)

    # Load and retrieve the prompting dimension of the target image
    target = Image.open(target_file)
    prompt_size = get_pdim(target)
    p_cols, p_rows = prompt_size
    logger.debug(f"prompting dimensions: {prompt_size}")

    # Resize and save a version of target to the rendering folder
    target.resize(prompt_size).save(out_dir/"target.png")
    log_output(logger, "target image saved to", out_dir/"target.png")

    # Load the plane and object coordinates
    coords = np.load(coords_file)
    pln_coords = coords['pln']
    obj_coords = coords['obj']

    for i in range(pln_coords.shape[0]):
        logger.debug(f"pln coordinates[{i}]: {pln_coords[i]}")

    # Ensure the winding order of the coordinates defining the plane is CCW
    # Since image coordinates have the y-axis pointing downward, the output
    # of is_ccw is inverted
    if is_ccw(pln_coords):
        pln_coords = np.flip(pln_coords, axis=0)

    # Construct the plane mask
    plane_mask = build_mask((p_rows, p_cols), pln_coords)
    plane_mask = erode_mask(plane_mask, 1)

    # Load and average the normals within the mask region
    normal = Image.open(normal_file)
    normal = np.array(normal.resize(prompt_size))
    pln_normal = np.mean(normal[plane_mask], axis=0).astype(np.float32)
    pln_normal = pln_normal / 127.5 - 1
    pln_normal = pln_normal / np.linalg.norm(pln_normal)
    logger.debug(f"plane normal: {pln_normal}")

    # Process Li et al.'s env map
    irois_hdr_file = out_dir/"irois.hdr"
    irois_exr_file = out_dir/"irois.exr"
    # Skip the generation if possible
    if irois_hdr_file.exists() and args.cache:
        log_output(logger, "found existing file at", irois_hdr_file)
        logger.info(f"[>] Li et al.'s env map generation will be skipped")

        # Resave the .exr file which might have been altered by pbrren.py
        irois_hdr = px.read(irois_hdr_file)
        px.write(irois_exr_file, irois_hdr)
    else:
        # Load Li et al.'s env map array
        irois = np.load(irois_file)
        logger.debug(f"irois env map shape: {irois.shape}")

        # Extract local lighting from Li et al.'s envmap
        obj_frac = (obj_coords[0] - 1.) / np.array([p_cols - 1., p_rows - 1.])
        irois_uv = obj_frac * np.array([irois.shape[1], irois.shape[0]]) - 1.
        irois_uv = irois_uv.astype(int)
        logger.debug(f"irois uv: {irois_uv}")

        # Add ground and rotate Li et al.'s environment map
        h_ground = int(args.g_fraction * HDR[1])
        h_intact = HDR[1] - h_ground
        irois_env = irois[irois_uv[1], irois_uv[0], :, :, :]
        irois_env = resize(
            irois_env, (HDR[0], h_intact), interpolation=INTER_LINEAR)
        irois_gnd = np.zeros([h_ground, HDR[0], 3], dtype=np.float32)
        irois_env = np.concatenate([irois_gnd, irois_env], axis=0)
        irois_hdr = rotate_env_map(irois_env, pln_normal)
        logger.debug(
            f"irois HDR range: [{np.min(irois_hdr)}, {np.max(irois_hdr)}]")

        # Export Li et al.'s env maps
        px.write(irois_hdr_file, np.flip(irois_hdr, axis=2))
        px.write(irois_exr_file, np.flip(irois_hdr, axis=2))
        log_output(logger, "Li et al.'s env map saved to", irois_hdr_file)
        log_output(logger, "Li et al.'s env map saved to", irois_exr_file)

    # Process Pratul et al.'s env map
    house_hdr_file = out_dir/"lighthouse.hdr"
    house_exr_file = out_dir/"lighthouse.exr"
    # Skip the generation if possible
    if house_hdr_file.exists() and args.cache:
        log_output(logger, "found existing file at", house_hdr_file)
        logger.info(f"[>] Pratul et al.'s env map generation will be skipped")

        # Resave the .exr file which might have been altered by pbrren.py
        house_hdr = px.read(house_hdr_file)
        px.write(house_exr_file, house_hdr)
    else:
        # Load Pratul et al.'s RGBA env map which must be converted to RGB
        house_env = Image.open(house_file).convert("RGB")
        logger.debug(f"house env map size: {house_env.size}")

        # Upscale Pratul et al.'s env map with StableDiffusion
        if args.upscale:
            logger.info(
                f"[>] upscaling Pratul et al.'s env map with StableDiffusion...")
            stable_diffusion_id = "stabilityai/stable-diffusion-x4-upscaler"
            filterwarnings("ignore", category=FutureWarning)
            pipe = StableDiffusionUpscalePipeline.from_pretrained(
                stable_diffusion_id, torch_dtype=tr.float16)
            pipe = pipe.to("cuda")

            pipe.enable_xformers_memory_efficient_attention()
            house_env = pipe(prompt="", image=house_env).images[0]
            filterwarnings("default", category=FutureWarning)

        # Convert Pratul et al.'s env map to HDR
        house_hdr = ldr_to_hdr(np.array(house_env))
        logger.debug(
            f"house HDR range: [{np.min(house_hdr)}, {np.max(house_hdr)}]")

        # Export Pratul et al.'s env maps
        px.write(str(house_hdr_file), house_hdr)
        px.write(str(house_exr_file), house_hdr)
        log_output(logger, "Pratul et al.'s env map saved to", house_hdr_file)
        log_output(logger, "Pratul et al.'s env map saved to", house_exr_file)

    # Load and resize the albedo map to the target size
    albedo = Image.open(albedo_file)
    albedo = albedo.resize(prompt_size)
    albedo.save(out_dir/"albedo.png")
    log_output(logger, "albedo map saved to", out_dir/"albedo.png")

    # Load and resize the rough map to the target size
    rough = Image.open(rough_file)
    rough = rough.resize(prompt_size)
    rough.save(out_dir/"rough.png")
    log_output(logger, "rough map saved to", out_dir/"rough.png")

    # Load and convolve the reference depth
    rdepth = np.load(rdepth_file)
    rdepth = convolve_ref_depth(rdepth, k_size=args.ksize)
    logger.debug(f"loaded ref_depth of shape: {rdepth.shape}")
    logger.debug(f"ref_depth range: [{np.min(rdepth)}, {np.max(rdepth)}]")

    # Convert image coordinates of the shadow plane to world coordinates
    pln_positions, ref_point = image_to_world(
        pln_coords, rdepth, args.fov, pln_normal)
    for i in range(pln_positions.shape[0]):
        logger.debug(f"pln positions[{i}]: {pln_positions[i]}")
    pln_positions = adapter.adapt_basis(pln_positions)

    # Adapt and assign the plane normal for each vertex
    pln_normal_pbrt = adapter.adapt_basis(pln_normal)
    pln_normal_pbrt = pln_normal_pbrt / np.linalg.norm(pln_normal_pbrt)
    pln_normals = np.tile(pln_normal_pbrt, (pln_positions.shape[0], 1))

    # Compute the plane's uv coordinates, with v facing up
    pln_u = (pln_coords[:, 0]) / (p_cols - 1.)
    pln_v = (p_rows - pln_coords[:, 1] - 1.) / (p_rows - 1.)
    pln_uv = np.column_stack([pln_u, pln_v]).astype(np.float32)

    # Define the plane indices of drawing and write out the plane shape file
    pln_indices = [0, 1, 2, 0, 2, 3]
    pln_shape_file = out_dir/"plane_shape.pbrt"
    writer.write_shape(
        pln_shape_file, pln_positions, pln_normals, pln_uv, pln_indices)
    log_output(logger, "pbrt shape file written to", pln_shape_file)

    # Convert image coordinates of the object to world coordinates
    logger.debug(f"obj coordinates: {obj_coords[0]}")
    obj_position, _ = image_to_world(
        obj_coords, rdepth, args.fov, pln_normal, ref_point)
    logger.debug(f"obj position: {obj_position[0]}")
    obj_position = adapter.adapt_basis(obj_position)

    # Define material and transform of the object
    if args.obj_material == 'glossy':
        m_textures, m_type, m_params = material.conductor(
            roughness=0.001, reflectance=np.array([0.8, 0.8, 0.8]))

    elif args.obj_material == 'diffuse':
        m_textures, m_type, m_params = material.coated_diffuse(
            roughness=0.2, albedo=np.array([0.8, 0.8, 0.8]))
        
    obj_transforms = writer.get_transform_sequence(
        translate=obj_position.flatten() + pln_normal_pbrt * args.obj_scale,
        scale=args.obj_scale, rotate=args.obj_rotate)
        
    # Define material of the plane, the albedo must be in exr
    p_textures, p_type, p_params = material.coated_conductor_texture(
        albedo_file=out_dir/"albedo.exr", rough_file=rough_file)

    # pbrt works with vertical fov, in degree
    fov_deg = args.fov / (p_cols / p_rows)

    # Generate I_all scene file description
    scene_writer_builder = writer.PBRW.Builder()
    scene_writer = scene_writer_builder\
        .sensor("perspective", fov_deg)\
        .sampler("zsobol", args.pixel_samples)\
        .integrator("volpath")\
        .film("spectral", p_cols, p_rows)\
        .build("scene.exr")
    
    if args.w_irois > 0.0:
        scene_writer.add_light_infinite(irois_exr_file, scale=args.w_irois)
    if args.w_house > 0.0:    
        scene_writer.add_light_infinite(house_exr_file, scale=args.w_house)
    scene_writer.add_material('obj_mat', m_textures, m_type, m_params)
    scene_writer.add_material('pln_mat', p_textures, p_type, p_params)

    obj_shape = f"Shape \"sphere\" \"float radius\" 1"
    scene_writer.add_attribute('obj_mat', obj_transforms, obj_shape)

    pln_shape = f"Import \"{pln_shape_file.name}\""
    scene_writer.add_attribute('pln_mat', [], pln_shape)

    scene_render_file = out_dir/"scene.pbrt"
    scene_writer.write_scene(scene_render_file)

    # Generate I_pln scene file description
    plane_writer_builder = writer.PBRW.Builder()
    plane_writer = plane_writer_builder\
        .sensor("perspective", fov_deg)\
        .sampler("zsobol", args.pixel_samples)\
        .integrator("volpath")\
        .film("spectral", p_cols, p_rows)\
        .build("plane.exr")
    
    if args.w_irois > 0.0:
        plane_writer.add_light_infinite(irois_exr_file, scale=args.w_irois)
    if args.w_house > 0.0:
        plane_writer.add_light_infinite(house_exr_file, scale=args.w_house)
    plane_writer.add_material('pln_mat', p_textures, p_type, p_params)

    plane_writer.add_attribute('pln_mat', [], pln_shape)

    plane_render_file = out_dir/"plane.pbrt"
    plane_writer.write_scene(plane_render_file)

    # Generate M_all scene file description
    mall_writer_builder = writer.PBRW.Builder()
    mall_writer = mall_writer_builder\
        .sensor("perspective", fov_deg)\
        .sampler("zsobol", 512)\
        .integrator("volpath")\
        .film("rgb", p_cols, p_rows)\
        .build("mask_all.png")
    
    mall_writer.add_light_distant(
        l_to=np.array([0.0, 0.0, -1.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mall_writer.add_light_distant(
        l_to=np.array([-1.0, 0.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mall_writer.add_light_distant(
        l_to=np.array([1.0, 0.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mall_writer.add_light_distant(
        l_to=np.array([0.0, -1.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mall_writer.add_light_distant(
        l_to=np.array([0.0, 1.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)

    diff_textures, diff_material, diff_params = material.diffuse()
    mall_writer.add_material('diff', diff_textures, diff_material, diff_params)

    mall_writer.add_attribute('diff', obj_transforms, obj_shape)
    mall_writer.add_attribute('diff', [], pln_shape)

    mall_render_file = out_dir/"mask_all.pbrt"
    mall_writer.write_scene(mall_render_file)

    # Generate M_obj scene file description
    mobj_film_name = "mask_obj.png"
    mobj_writer_builder = writer.PBRW.Builder()
    mobj_writer = mobj_writer_builder\
        .sensor("perspective", fov_deg)\
        .sampler("zsobol", 512)\
        .integrator("volpath")\
        .film("rgb", p_cols, p_rows)\
        .build("mask_obj.png")
    
    mobj_writer.add_light_distant(
        l_to=np.array([0.0, 0.0, -1.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mobj_writer.add_light_distant(
        l_to=np.array([-1.0, 0.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mobj_writer.add_light_distant(
        l_to=np.array([1.0, 0.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mobj_writer.add_light_distant(
        l_to=np.array([0.0, -1.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)
    mobj_writer.add_light_distant(
        l_to=np.array([0.0, 1.0, 0.0], dtype=np.float32),
        rgb_L=np.array([1.0, 1.0, 1.0], dtype=np.float32),)

    mobj_writer.add_material('diff', diff_textures, diff_material, diff_params)
    mobj_writer.add_attribute('diff', obj_transforms, obj_shape)

    mobj_render_file = out_dir/"mask_obj.pbrt"
    mobj_writer.write_scene(mobj_render_file)

    log_output(logger,"scene description file written to", scene_render_file)
    log_output(logger,"scene description file written to", plane_render_file)
    log_output(logger,"scene description file written to", mall_render_file)
    log_output(logger,"scene description file written to", mobj_render_file)