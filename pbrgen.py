from argparse import ArgumentParser
from cv2 import resize, INTER_LINEAR
from diffusers import StableDiffusionUpscalePipeline
import numpy as np
from os import makedirs
from os.path import abspath
from pathlib import Path
from PIL import Image
from pyexr import write
from torch import float16

from vobj.dimension import get_pdim, HDR
from vobj.operation import build_mask, erode_mask
from vobj.transform import rotate_env_map, ldr_to_hdr
from vobj.validator import is_ccw

from terminal import get_logger, verify_path, log_output

if __name__ == "__main__":
    parser = ArgumentParser(
        description="Generates resources for rendering with pbrt.")

    parser.add_argument('-debug', action='store_true',
        help="run in debug mode")
    parser.add_argument('-upscale', action='store_true',
        help="use StableDiffuser to upscale Pratul et al.'s env map")
    parser.add_argument('--res-dir', type=str, required=True, 
        help="path to the directory containing files generated by mapgen.py")
    parser.add_argument('--fov', type=float, default=63.5, 
        help="field of view in the x-axis, default to 63.5")

    args = parser.parse_args()

    verbose = 'DEBUG' if args.debug else 'INFO'
    logger = get_logger(__name__, verbose)

    # All resource files
    res_dir = Path(abspath(args.res_dir))
    target_file = res_dir/"target.png"
    coords_file = res_dir/"coords.npz"
    normal_file = res_dir/"normal.png"
    albedo_file = res_dir/"albedo.png"
    rdepth_file = res_dir/"ref_depth.npy"
    rough_file = res_dir/"rough.png"
    irois_file = res_dir/"irois.npy"
    house_file = res_dir/"lighthouse.png"

    # Verify the existence of all resources
    try:
        verify_path(logger, res_dir)
        verify_path(logger, target_file)
        verify_path(logger, coords_file)
        verify_path(logger, normal_file)
        verify_path(logger, albedo_file)
        verify_path(logger, rdepth_file)
        verify_path(logger, rough_file)
        verify_path(logger, irois_file)
        verify_path(logger, house_file)
    except FileNotFoundError:
        exit(1)

    # Generate pbrt resources to a separate folder
    out_dir = res_dir/"pbrt"
    makedirs(out_dir, exist_ok=True)

    # Load and retrieve the prompting dimension of the target image
    target = Image.open(target_file)
    p_cols, p_rows = get_pdim(target)
    logger.debug(f"prompting dimensions: ({p_cols}, {p_rows})")

    # Load the plane and object coordinates
    coords = np.load(coords_file)
    pln_coords = coords['pln']
    obj_coords = coords['obj']

    logger.debug(f"pln coordinates[0]: {pln_coords[0]}")
    logger.debug(f"pln coordinates[1]: {pln_coords[1]}")
    logger.debug(f"pln coordinates[2]: {pln_coords[2]}")
    logger.debug(f"pln coordinates[3]: {pln_coords[3]}")
    logger.debug(f"obj coordinates[0]: {obj_coords[0]}")

    # Ensure the winding order of the coordinates defining the plane is CCW
    # Since image coordinates have the y-axis pointing downward, the output
    # of is_ccw is inverted
    if is_ccw(pln_coords):
        pln_coords = np.flip(pln_coords, axis=0)

    # Construct the plane mask
    plane_mask = build_mask((p_rows, p_cols), pln_coords)
    plane_mask = erode_mask(plane_mask, 1)

    # Load and average the normals within the mask region
    normal = Image.open(normal_file)
    normal = np.array(normal.resize(get_pdim(target)))
    pln_normal = np.mean(normal[plane_mask], axis=0).astype(np.float32)
    pln_normal = pln_normal / 127.5 - 1
    pln_normal = pln_normal / np.linalg.norm(pln_normal)
    logger.debug(f"plane normal: {pln_normal}")

    # Load Li et al.'s env map
    irois = np.load(irois_file)
    logger.debug(f"irois env map shape: {irois.shape}")

    # Extract local lighting from Li et al.'s envmap
    obj_frac = (obj_coords[0] - 1.) / np.array([p_cols - 1., p_rows - 1.])
    irois_uv = obj_frac * np.array([irois.shape[1], irois.shape[0]]) - 1.
    irois_uv = irois_uv.astype(int)
    logger.debug(f"irois uv: {irois_uv}")

    # Rotate Li et al.'s environment map
    irois_env = irois[irois_uv[1], irois_uv[0], :, :, :]
    irois_env = resize(irois_env, HDR, interpolation=INTER_LINEAR)
    irois_hdr = rotate_env_map(irois_env, pln_normal)
    logger.debug(f"irois HDR range: [{np.min(irois_hdr)}, {np.max(irois_hdr)}]")

    # Export Li et al.'s env maps
    irois_hdr_file = out_dir/"irois.hdr"
    irois_exr_file = out_dir/"irois.exr"
    write(str(irois_hdr_file), np.flip(irois_hdr, axis=2))
    write(str(irois_exr_file), np.flip(irois_hdr, axis=2))
    log_output(logger, "Li et al.'s env map saved to", irois_hdr_file)
    log_output(logger, "Li et al.'s env map saved to", irois_exr_file)

    # Load Pratul et al.'s RGBA env map which must be converted to RGB
    house_env = Image.open(house_file).convert("RGB")
    logger.debug(f"house env map size: {house_env.size}")

    # Upscale Pratul et al.'s env map with StableDiffusion
    if args.upscale:
        stable_diffusion_id = "stabilityai/stable-diffusion-x4-upscaler"
        pipe = StableDiffusionUpscalePipeline.from_pretrained(
            stable_diffusion_id, torch_dtype=float16)
        pipe = pipe.to("cuda")

        pipe.enable_xformers_memory_efficient_attention()
        house_env = pipe(prompt="", image=house_env).images[0]

    # Convert Pratul et al.'s env map to HDR
    house_hdr = ldr_to_hdr(np.array(house_env))
    logger.debug(f"house HDR range: [{np.min(house_hdr)}, {np.max(house_hdr)}]")

    # Export Pratul et al.'s env maps
    house_hdr_file = out_dir/"lighthouse.hdr"
    house_exr_file = out_dir/"lighthouse.exr"
    write(str(house_hdr_file), house_hdr)
    write(str(house_exr_file), house_hdr)
    log_output(logger, "Pratul et al.'s env map saved to", house_hdr_file)
    log_output(logger, "Pratul et al.'s env map saved to", house_exr_file)

    # Load and resize the albedo map to the target size
    albedo = Image.open(albedo_file)
    albedo = albedo.resize(get_pdim(target))
    albedo.save(out_dir/"albedo.png")
    log_output(logger, "albedo map saved to", out_dir/"albedo.png")

    # Load and resize the rough map to the target size
    rough = Image.open(rough_file)
    rough = rough.resize(get_pdim(target))
    rough.save(out_dir/"rough.png")
    log_output(logger, "rough map saved to", out_dir/"rough.png")

    # Load the reference depth
    rdepth = np.load(rdepth_file)
    logger.debug(f"loaded ref_depth of shape: {rdepth.shape}")
    logger.debug(f"ref_depth range: [{np.min(rdepth)}, {np.max(rdepth)}]")