from argparse import ArgumentParser
from Imath import PixelType
from os import makedirs
from os.path import abspath
from pathlib import Path

import cv2 as cv
import numpy as np
import OpenEXR as exr
import pyexr as px

from vobj.operation import erode_mask
from vobj.transform import ldr_to_hdr

from terminal import get_logger, verify_path, log_output


def load_exr(file: Path):
    exr_file = exr.InputFile(str(file))

    # Read R, G, and B channels
    r_raw = exr_file.channel('R', PixelType(PixelType.FLOAT))
    g_raw = exr_file.channel('G', PixelType(PixelType.FLOAT))
    b_raw = exr_file.channel('B', PixelType(PixelType.FLOAT))

    # Convert raw bytes to numpy arrays
    r_array = np.frombuffer(r_raw, dtype=np.float32)
    g_array = np.frombuffer(g_raw, dtype=np.float32)
    b_array = np.frombuffer(b_raw, dtype=np.float32)

    # Get image dimensions
    rows = exr_file.header()['displayWindow'].max.y + 1 - exr_file.header()['displayWindow'].min.y
    cols = exr_file.header()['displayWindow'].max.x + 1 - exr_file.header()['displayWindow'].min.x

    # Reshape vectors into image arrays
    r = np.reshape(r_array, (rows, cols))
    g = np.reshape(g_array, (rows, cols))
    b = np.reshape(b_array, (rows, cols))

    return np.stack((b, g, r), axis=2)


def load_mask(file: Path) -> np.ndarray:
    img = cv.imread(str(file))
    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)

    _, mask = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)
    return mask > 0


if __name__ == "__main__":
    parser = ArgumentParser(
        description="Insert the rendered virtual object.")
    
    parser.add_argument('-debug', action='store_true',
        help="run in debug mode")
    parser.add_argument('--res-dir', type=str, required=True, 
        help="path to the directory containing files generated by pbrren.py")
    parser.add_argument("--target", type=str, default="",
        help="path to the target image, default to target.png in res dir")
    parser.add_argument('--output', type=str, default="", 
        help="output file name, only EXR is allowed")

    args = parser.parse_args()

    verbose = 'DEBUG' if args.debug else 'INFO'
    logger = get_logger(__name__, verbose)

    res_dir = Path(abspath(args.res_dir))
    target_file = res_dir/"target.png" if not args.target else args.target
    i_file = Path(abspath(target_file))
    i_all_file = res_dir/"scene.exr"
    i_pln_file = res_dir/"plane.exr"
    m_all_file = res_dir/"mask_all.png"
    m_obj_file = res_dir/"mask_obj.png"

    try:
        verify_path(logger, res_dir)
        verify_path(logger, i_file)
        verify_path(logger, i_all_file)
        verify_path(logger, i_pln_file)
        verify_path(logger, m_all_file)
        verify_path(logger, m_obj_file)
    except FileNotFoundError:
        exit(1)

    i = cv.imread(str(i_file))
    logger.info(f"[>] loaded png {i_file.name}")

    i_all = load_exr(i_all_file)
    logger.info(f"[>] loaded exr {i_all_file.name}")

    i_pln = load_exr(i_pln_file)
    logger.info(f"[>] loaded exr {i_pln_file.name}")

    m_all = load_mask(m_all_file)
    logger.info(f"[>] loaded mask {m_all_file.name}")

    m_obj = load_mask(m_obj_file)
    logger.info(f"[>] loaded mask {m_obj_file.name}")

    # Make the target image HDR
    i = ldr_to_hdr(i)

    # Process masks
    m_all = erode_mask(m_all, 4)
    m_pln = np.clip(m_all.astype(float) - m_obj.astype(float), 0, None)
    m_pln = m_pln > 0

    m_all = np.stack([m_all, m_all, m_all], axis=2)
    m_pln = np.stack([m_pln, m_pln, m_pln], axis=2)
    m_obj = np.stack([m_obj, m_obj, m_obj], axis=2)

    k_sd = np.maximum(i_all, 1e-10) / np.maximum(i_pln, 1e-10) * m_pln
    k_sd = np.minimum(k_sd, 1)
    
    # Insert the object
    h = i * (1.0 - m_all) + i * k_sd * m_all
    h = i_all * m_obj + h * (1.0 - m_obj)
    logger.debug(f"result range: {np.min(h)} - {np.max(h)}")

    out_file = res_dir/args.output if args.output else res_dir/"result.exr"
    makedirs(out_file.parent, exist_ok=True)
    if out_file.suffix != ".exr":
        logger.error(f"unsupport output file format: {out_file.suffix}")
        exit(1)
    px.write(str(out_file), np.flip(h, axis=2))
    log_output(logger, "result saved to", out_file)