from datetime import datetime
from pathlib import Path
import numpy as np


class PBRW:
    def __init__(self):
        self.look_at = np.array([
            [ 0.0,  0.0,  0.0],
            [-1.0,  0.0,  0.0],
            [ 0.0,  0.0,  1.0],
        ], dtype=np.float32)

        self.camera = "perspective"
        self.fov = 40
        self.lens_radius = 0

        self.sampler = "zsobol"
        self.pixel_samples = 1024

        self.integrator = "volpath"

        self.film = "rgb"
        self.xres = 640
        self.yres = 480
        self.film_name = None

        self.lights = {
            'infinite': [],
            'distant': [],
        }

        self.materials = {}
        self.attributes = []

    
    class Builder:
        def __init__(self):
            self.__pbrw = PBRW()


        def look_at(self, look_at):
            self.__pbrw.look_at = look_at
            return self
        

        def sensor(self, camera: str, fov_deg, lens_radius=0):
            self.__pbrw.camera = camera
            self.__pbrw.fov = fov_deg
            self.__pbrw.lens_radius = lens_radius
            return self
        

        def sampler(self, sampler: str, n_samples):
            self.__pbrw.sampler = sampler
            self.__pbrw.pixel_samples = n_samples
            return self
        

        def integrator(self, integrator: str):
            self.__pbrw.integrator = integrator
            return self
        

        def film(self, film: str, x_resolution, y_resolution):
            self.__pbrw.film = film
            self.__pbrw.xres = x_resolution
            self.__pbrw.yres = y_resolution

            return self
        

        def build(self, film_name: str):
            if self.__pbrw.film == "spectral" and not film_name.endswith(".exr"):
                raise ValueError(f"film is {self.__film} but output format is not exr: {film_name}")
            
            self.__pbrw.film_name = film_name

            return self.__pbrw

    
    def add_light_infinite(self, env_map: Path, illuminance=None, scale=None):
        if not env_map.exists():
            raise FileNotFoundError(env_map.resolve().relative_to(Path.cwd()))
        
        self.lights['infinite'].append({
            'file': env_map,
            'illuminance': illuminance,
            'scale': scale,
        })
        return self
    

    def add_light_distant(self, 
            l_from: np.ndarray = np.array([0.0, 0.0, 0.0], dtype=np.float32),
            l_to: np.ndarray = np.array([0.0, 0.0, 1.0], dtype=np.float32),
            rgb_L: np.ndarray = np.array([1.0, 1.0, 1.0], dtype=np.float32),
            illuminance=None, 
            scale=None,
        ):
        
        self.lights['distant'].append({
            'from': l_from,
            'to': l_to,
            'L': rgb_L,
            'illuminance': illuminance,
            'scale': scale,
        })
        return self
    

    def add_material(self, name, textures, material, params):
        self.materials[name] = {
            'textures': textures,
            'material': material,
            'params': params,
        }
        return self


    def add_attribute(self, mat_name, transforms, shape):
        self.attributes.append({
            'mat_name': mat_name,
            'transforms': transforms,
            'shape': shape,
        })
        return self
    

    def write_scene(self, file: Path):
        with open(file, 'w') as scene_file:
            # Header comments
            current_time = datetime.now()
            f_time = current_time.strftime("%Y-%m-%d %H:%M:%S")
            scene_file.write(f"# File generated by \"pbrw.py\" - {f_time}\n")

            # Scene-wide descriptions
            self._write_look_at(scene_file)
            self._write_sensor(scene_file)
            self._write_sampler(scene_file)
            self._write_integrator(scene_file)
            self._write_film(scene_file)

            # World begin
            scene_file.write(f"\nWorldBegin\n")

            # Lights and attributes
            self._write_lights(scene_file)
            self._write_attributes(scene_file)
        

    def _write_look_at(self, file):
        file.write("\nLookAt\n")
        for v in self.look_at:
            file.write(f"\t{v[0]}  {v[1]}  {v[2]}\n")


    def _write_sensor(self, file):
        file.write(f"\nCamera \"{self.camera}\"\n")
        file.write(f"\t\"float fov\" [ {self.fov} ]\n")
        file.write(f"\t\"float lensradius\" [ {self.lens_radius} ]\n")


    def _write_sampler(self, file):
        file.write(f"\nSampler \"{self.sampler}\"\n")
        file.write(f"\t\"integer pixelsamples\" [ {self.pixel_samples} ]\n")


    def _write_integrator(self, file):
        file.write(f"\nIntegrator \"{self.integrator}\"\n")


    def _write_film(self, file):
        file.write(f"\nFilm \"{self.film}\"\n")
        file.write(f"\t\"integer xresolution\" [ {self.xres} ]\n")
        file.write(f"\t\"integer yresolution\" [ {self.yres} ]\n")
        file.write(f"\t\"string filename\" [ \"{self.film_name}\" ]\n")


    def _write_lights(self, file):
        # "infinite" lights
        for light in self.lights['infinite']:
            file.write("\nLightSource \"infinite\"\n")
            file.write(f"\t\"string filename\" [ \"{light['file'].name}\" ]\n")
            if not light['illuminance'] is None:
                file.write(f"\t\"float illuminance\" [ {light['illuminance']} ]\n")
            if not light['scale'] is None:
                file.write(f"\t\"float scale\" [ {light['scale']} ]\n")
        
        # "distant" lights
        for light in self.lights['distant']:
            file.write("\nLightSource \"distant\"\n")
            file.write(f"\t\"point3 from\" {light['from']}\n")
            file.write(f"\t\"point3 to\" {light['to']}\n")
            file.write(f"\t\"rgb L\" {light['L']}\n")
            if not light['illuminance'] is None:
                file.write(f"\t\"float illuminance\" [ {light['illuminance']} ]\n")
            if not light['scale'] is None:
                file.write(f"\t\"float scale\" [ {light['scale']} ]\n")


    def _write_attributes(self, file):
        for attr in self.attributes:
            file.write("\nAttributeBegin\n")

            self._write_material(file, attr['mat_name'], line_prefix='\t')

            for tf in attr['transforms']:
                file.write(f"\t{tf}\n")

            file.write(f"\t{attr['shape']}\n")

            file.write("AttributeEnd\n")


    def _write_material(self, file, mat_name, line_prefix=''):
        # textures, material, params = self.materials[mat_name]
        
        for texture in self.materials[mat_name]['textures']:
            file.write(f"{line_prefix}{texture}\n")

        file.write(f"{line_prefix}Material \"{self.materials[mat_name]['material']}\"\n")

        for param in self.materials[mat_name]['params']:
            file.write(f"{line_prefix}\t\"{param['name']}\" {param['value']}\n")
    

def write_shape(
    file: Path, 
    positions: np.ndarray[np.float32], 
    normals: np.ndarray[np.float32], 
    uv: np.ndarray[np.float32], 
    indices: np.ndarray[int] | list[int]
):
    with open(file, 'w') as shape_file:
        # Header comments
        current_time = datetime.now()
        f_time = current_time.strftime("%Y-%m-%d %H:%M:%S")
        shape_file.write(f"# File generated by \"pbrw.py\" - {f_time}\n\n")

        shape_file.write("Shape \"trianglemesh\"\n")

        # Write positions
        shape_file.write("\t\"point3 P\" [\n")
        for p in positions: shape_file.write(f"\t\t{p[0]} {p[1]} {p[2]}\n")
        shape_file.write("\t]\n")

        # Write normals
        shape_file.write("\t\"normal N\" [\n")
        for n in normals: shape_file.write(f"\t\t{n[0]} {n[1]} {n[2]}\n")
        shape_file.write("\t]\n")

        # Write UVs
        shape_file.write("\t\"point2 uv\" [\n")
        for t in uv: shape_file.write(f"\t\t{t[0]} {t[1]}\n")
        shape_file.write("\t]\n")

        # Write indices
        shape_file.write("\t\"integer indices\" [")
        for i, n in zip(indices, range(len(indices))):
            if n % 3 == 0: shape_file.write("\n\t\t")
            else: shape_file.write(" ")
            shape_file.write(f"{i}")
        shape_file.write("\n\t]\n")


def get_transform_sequence(
    rotate: tuple[float, float, float, float] | np.ndarray = (0, 1, 0, 0), 
    scale: float | tuple[float, float, float] | np.ndarray = 1.0, 
    translate: tuple[float, float, float] | np.ndarray = (0, 0, 0),
) -> list[str]:
    if isinstance(scale, float):
        scale = np.array([scale, scale, scale])

    return [
        f"Translate {translate[0]} {translate[1]} {translate[2]}",
        f"Scale {scale[0]}  {scale[1]}  {scale[2]}",
        f"Rotate {rotate[0]} {rotate[1]} {rotate[2]} {rotate[3]}",
    ]